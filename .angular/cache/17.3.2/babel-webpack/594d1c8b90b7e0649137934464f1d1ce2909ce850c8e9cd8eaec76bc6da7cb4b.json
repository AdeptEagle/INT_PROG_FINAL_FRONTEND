{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, mergeMap, materialize, dematerialize } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor() {\n      this.users = [{\n        id: 1,\n        email: 'admin@example.com',\n        password: 'admin',\n        role: 'Admin',\n        employeeId: 1\n      }, {\n        id: 2,\n        email: 'user@example.com',\n        password: 'user',\n        role: 'User',\n        employeeId: 2\n      }];\n      this.employees = [{\n        id: 1,\n        employeeId: 'EMP001',\n        userId: 1,\n        position: 'Developer',\n        departmentId: 1,\n        hireDate: '2025-01-01',\n        status: 'Active'\n      }, {\n        id: 2,\n        employeeId: 'EMP002',\n        userId: 2,\n        position: 'Designer',\n        departmentId: 2,\n        hireDate: '2025-02-01',\n        status: 'Active'\n      }];\n      this.departments = [{\n        id: 1,\n        name: 'Engineering',\n        description: 'Software development team',\n        employeeCount: 1\n      }, {\n        id: 2,\n        name: 'Marketing',\n        description: 'Marketing team',\n        employeeCount: 1\n      }];\n      this.workflows = [{\n        id: 1,\n        employeeId: 1,\n        type: 'Onboarding',\n        details: {\n          task: 'Setup workstation'\n        },\n        status: 'Pending'\n      }];\n      this.requests = [{\n        id: 1,\n        employeeId: 2,\n        type: 'Equipment',\n        requestItems: [{\n          name: 'Laptop',\n          quantity: 1\n        }],\n        status: 'Pending'\n      }];\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      return of(null).pipe(mergeMap(() => this.handleRoute(url, method, headers, body))).pipe(materialize()).pipe(delay(500)).pipe(dematerialize());\n    }\n    handleRoute(url, method, headers, body) {\n      // Auth\n      if (url.endsWith('/accounts/authenticate') && method === 'POST') {\n        const {\n          email,\n          password\n        } = body;\n        const user = this.users.find(u => u.email === email && u.password === password);\n        if (!user) return throwError(() => new Error('Invalid credentials'));\n        return of(new HttpResponse({\n          status: 200,\n          body: {\n            ...user,\n            token: 'fake-jwt-token'\n          }\n        }));\n      }\n      // Accounts\n      if (url.endsWith('/accounts') && method === 'GET') {\n        return this.authorize(headers, 'Admin', () => of(new HttpResponse({\n          status: 200,\n          body: this.users\n        })));\n      }\n      // Employees\n      if (url.endsWith('/employees') && method === 'GET') {\n        return this.authorize(headers, null, () => of(new HttpResponse({\n          status: 200,\n          body: this.employees\n        })));\n      }\n      if (url.endsWith('/employees') && method === 'POST') {\n        return this.authorize(headers, 'Admin', () => {\n          const employee = {\n            id: this.employees.length + 1,\n            ...body\n          };\n          this.employees.push(employee);\n          return of(new HttpResponse({\n            status: 201,\n            body: employee\n          }));\n        });\n      }\n      if (url.match(/\\/employees\\/\\d+$/) && method === 'GET') {\n        const id = parseInt(url.split('/').pop());\n        const employee = this.employees.find(e => e.id === id);\n        return this.authorize(headers, null, () => employee ? of(new HttpResponse({\n          status: 200,\n          body: employee\n        })) : throwError(() => new Error('Employee not found')));\n      }\n      if (url.match(/\\/employees\\/\\d+$/) && method === 'PUT') {\n        return this.authorize(headers, 'Admin', () => {\n          const id = parseInt(url.split('/').pop());\n          const index = this.employees.findIndex(e => e.id === id);\n          if (index === -1) return throwError(() => new Error('Employee not found'));\n          this.employees[index] = {\n            id,\n            ...body\n          };\n          return of(new HttpResponse({\n            status: 200,\n            body: this.employees[index]\n          }));\n        });\n      }\n      if (url.match(/\\/employees\\/\\d+$/) && method === 'DELETE') {\n        return this.authorize(headers, 'Admin', () => {\n          const id = parseInt(url.split('/').pop());\n          this.employees = this.employees.filter(e => e.id !== id);\n          return of(new HttpResponse({\n            status: 200,\n            body: {\n              message: 'Employee deleted'\n            }\n          }));\n        });\n      }\n      // Departments\n      if (url.endsWith('/departments') && method === 'GET') {\n        return this.authorize(headers, null, () => of(new HttpResponse({\n          status: 200,\n          body: this.departments\n        })));\n      }\n      if (url.endsWith('/departments') && method === 'POST') {\n        return this.authorize(headers, 'Admin', () => {\n          const department = {\n            id: this.departments.length + 1,\n            ...body,\n            employeeCount: 0\n          };\n          this.departments.push(department);\n          return of(new HttpResponse({\n            status: 201,\n            body: department\n          }));\n        });\n      }\n      if (url.match(/\\/departments\\/\\d+$/) && method === 'PUT') {\n        return this.authorize(headers, 'Admin', () => {\n          const id = parseInt(url.split('/').pop());\n          const index = this.departments.findIndex(d => d.id === id);\n          if (index === -1) return throwError(() => new Error('Department not found'));\n          this.departments[index] = {\n            id,\n            ...body,\n            employeeCount: this.departments[index].employeeCount\n          };\n          return of(new HttpResponse({\n            status: 200,\n            body: this.departments[index]\n          }));\n        });\n      }\n      if (url.match(/\\/departments\\/\\d+$/) && method === 'DELETE') {\n        return this.authorize(headers, 'Admin', () => {\n          const id = parseInt(url.split('/').pop());\n          this.departments = this.departments.filter(d => d.id !== id);\n          return of(new HttpResponse({\n            status: 200,\n            body: {\n              message: 'Department deleted'\n            }\n          }));\n        });\n      }\n      return next.handle({\n        url,\n        method,\n        headers,\n        body\n      });\n    }\n    authorize(headers, requiredRole, success) {\n      const user = this.getUser(headers);\n      if (!user) return throwError(() => new Error('Unauthorized'));\n      if (requiredRole && user.role !== requiredRole) return throwError(() => new Error('Forbidden'));\n      return success();\n    }\n    getUser(headers) {\n      const authHeader = headers.get('Authorization');\n      if (!authHeader || authHeader !== 'Bearer fake-jwt-token') return null;\n      return this.users[0]; // Simplified: Always return the first user for mock\n    }\n    static #_ = this.ɵfac = function FakeBackendInterceptor_Factory(t) {\n      return new (t || FakeBackendInterceptor)();\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: FakeBackendInterceptor,\n      factory: FakeBackendInterceptor.ɵfac\n    });\n  }\n  return FakeBackendInterceptor;\n})();\nexport const fakeBackendProvider = {\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}